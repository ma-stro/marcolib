;******************************************************************(in-package cr);------------------------------------------------------------------;******************************************************************; FUNCTIONS:;	make-gliss-model;******************************************************************;------------------------------------------------------------------; FUNCTIONS;------------------------------------------------------------------(defun make-gliss-model (llfq lmkrs &optional llamp)"Make a glissando-like model.llfq: list of list of beg and end frequencies (and an optional ston and exp)lmkrs: list of markers specifying the starting points of each notellamp: optional list of list of beg and end amplitudes (and an optional ston and exp)Each step will become a class array.NB:The elements of lamp or lfq can be either lists or numbers. Since a Chroma array    needs at least two elements, numbers or lists of one element will need to    have at least 2 elements.If the amplitudes and frequencies have a different amount of elements, the model will   stop when the first list has come to an end."  (let* ((nev (1- (length lmkrs)))         (fqls          (prepare-fqls llfq nev)))    (if llamp      (make-cseq fqls lmkrs (prepare-amps llamp nev (length (first fqls))))      (make-cseq fqls lmkrs)))); (make-gliss-model '((100 200 300) (1000 2000 3000) (0.0) (0.5 -0.5)) '(0 1 2 3 4) '((100) (200)) )(defun prepare-fqls (llfq nev)"Prepare fqls for make-gliss-model"  (om::mat-trans   (loop for el in (om::mat-trans llfq)         collect (build-sequence (first el)                                 (second el)                                 nev                                 (ifn (third el) 0.0 (third el))                                 (ifn (fourth el) 0.0 (fourth el))))));(prepare-fqls '((100 200 300) (1000 2000 3000)) 4)(defun prepare-amps (lamp nev nlists)"Prepare amps for make-gliss-model.Various startegies:amp is one value = prepare nev lists of llists times the same value.amp is one list = various not evolvingamp is a llist = as fqls (if some vals are missing, repeat the last one)"  (cond   ((numberp lamp)    (rept nev (rept nlists lamp)))   ((numberp (first lamp))    (rept nev (l-val nlists lamp)))   ((listp (first lamp))    (let ((amps (mapcar #'(lambda (x) (l-val nlists x)) lamp)))      (om::mat-trans       (loop for el in (om::mat-trans amps)             collect (build-sequence (first el)                                     (second el)                                     nev)))))    (t (error "Unknow kind of amplitude structure, sir ~a :~% ~a" (getenv 'CRUSER) lamp)))); (prepare-amps 100 5 3); (prepare-amps '(100 101) 5 3); (prepare-amps '((100 110 120) (200 210 220)) 5 3); (prepare-amps '((100) (200 210)) 5 3);------------------------------------------------------------------;******************************************************************