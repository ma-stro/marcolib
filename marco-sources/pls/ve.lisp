;*****************************************************************************;-------| PULS SYSTEM;-------| This file is: $LLpls/ve.lisp;-------| Version V1.0: Feb 6, 1990;-------| Modified: Mar 2000 (added type DVE);-------| By Marco Stroppa;-------| Copyright 1990 IRCAM;*****************************************************************************(in-package chroma); PACKAGE TO DEAL WITH VIRTUAL ENVELOPES;                 ASSOCIATED TYPE NAME: VE; DESCRIPTION OF THE DATA STRUCTURE:;    A Virtual Envelope consists of a break-point function of type FUN;	with an associated internal number that will be used when converting;	virtual envelopes to structures recognized by real synthesizers.;MODIF 2000;    In case the structure is not recognized (e.g. an object of type "fun" ;       and not "ve" for csound), appropriate synthesizer-dependent actions;       are taken:;    csound:;        put the fun object into a "hash table" and assign to it a default;            GEN number (see default variables: GEN-MIN, GEN-MAX, GEN-CURR,;            GEN-FILE and the new type "DVE");        if the fun object already exists (use a function with a threshold to;           decide) return the GEN number associated to it;        at the end, when loading the functions for csound, compile those;            contained in GEN-FILE if the file exists; CURRENT IMPLEMENTATION:;	cons of FUN and number; AVAILABLE FUNCTIONS:;	CONSTRUCTORS: make_ve;	SELECTORS:    fun_ve;		      name_ve;		      num_ve;		      s_ve;	PREDICATES:   is_ve;                     is-empty_ve;	INFO:	      print_ve;		      short-print_ve; DESCRIPTION OF THE PACKAGE:;	NAME:		make_ve  (CONSTRUCTOR);	TYPE:		Expr with 2 arguments;	CALL:		(make_ve fun num);	FUNCTION:	define and initialize a structure of type VE;			"fun" must be of type FUN;	VALUE:		the new structure;	SOURCE:		$LLpls/ve.ll(defun make_ve (fun num)    (pls-check-type 'FUN fun 'make_ve)    (attach-type 'VE (cons num fun)) );	NAME:		fun_ / num_ / name_ve  (SELECTORS);	TYPE:		Expr with 1 argument;	CALL:		(fun ... _ve ve);	FUNCTION:	return the function, the number and a string derived;			   from the number of ve;	VALUE:		the new data;	SOURCE:		$LLpls/ve.ll(defun fun_ve (ve)    (pls-check-type 'VE ve 'fun_ve)    (cdr (contents ve)) )(defun num_ve (ve)    (pls-check-type 'VE ve 'num_ve)    (car (contents ve)) )(defun name_ve (ve)    (pls-check-type 'VE ve 'name_ve)    (catenate 've_ (num_ve ve)) );	NAME:		s_ve  (SELECTORS);	TYPE:		Expr with 1  or 2 arguments;	CALL:		(s_ve ve [ synth ] );	FUNCTION:	return the format of the function envelope appropriate;			   to each known synthesizer;			if synth is not specified, the current synthesizer's;			   name is used; MODIF 2000          if the structure is not of type VE, it is a dynamic;                          function and will call DVE instructions;	VALUE:		the new data;	SOURCE:		$LLpls/ve.ll(defun s_ve (ve &rest synth);    (pls-check-type 'VE ve 's_ve)   ; CAN NOW ALSO ACCEPT OTHER TYPES  (let ((syn (ifn synth (synth-name) (car synth))) )      (case (pls-type ve)            ((VE)	     (syn-ve ve syn))            (otherwise		(add_dve ve)))))(defun syn-ve (ve synth)  (case synth    ((csound)     (num_ve ve))    (t     (error-synth 's_ve synth))) )     ;	NAME:		is/is-empty_ve  (PREDICATE);	TYPE:		Expr with 1 argument;	CALL:		(is_ve ve);	VECTION:	test whether the argument is a structure of type VE;	VALUE:		t or nil according to the test;	SOURCE:		$LLpls/ve.ll(defun is_ve (ve)  (when (is-tagged ve)   (eq (pls-type ve) 'VE)))(defun is-empty_ve (ve)  (when (is-tagged ve)   (is-empty (fun_ve ve))));	NAME:		print_/short-print_ve  (INFO);	TYPE:		Expr with 1 argument;	CALL:		(print_ve ve);			(short-print_ve ve);	VECTION:	nicely or shortely print a structure of type VE;	VALUE:		the string 'done;	SOURCE:		$LLpls/ve.ll(defun print_ve (ve)    (format t "VIRTUAL ENVELOPE - STRUCTURE OF TYPE : ~a~%" (pls-type ve))    (format t "        NUM  = ~a~%" (num_ve ve))    (format t "        NAME = ~a~%" (name_ve ve))    (format t "        FUN ---> ")    (prnt (fun_ve ve)) )(defun short-print_ve (ve)    (format t "VE: NUM  = ~a~%" (num_ve ve))    (format t "    NAME = ~a~%" (name_ve ve))    (format t "    FUN ---> ")    (short-prnt (fun_ve ve)) )