(in-package :cr);=========================definir des predicats(defun good-cs-p (min max &rest l)  (ignore-errors   (let ((cs (cs_vps (make_vps (midi->pch l)))))     (and (<= cs max) (>= cs min)))))(defun surface-p (min max &rest l)  (ignore-errors   (let ((densite (dens_vps (make_vps (midi->pch l)))))     (and (<= densite max) (>= densite min)))))(in-package :s)(defmacro apply-n-time (fun params times)  `(let ((*counter* 0)          (*result* nil))     (catch 'end       (s::for-effects (let ((rep (,fun ,.params)))                         (push  (print rep) *result*)                         (setf *counter* (length *result*))                         (when (or (= *counter* ,times) (null rep)) (s::throw 'end *result*)))))))(defun probleme (nbVar sp surf mincs maxcs)  (solution   (let* ( (VarArray (loop for i from 1 to nbVar                           collect (an-integer-betweenv sp (+ sp surf))) ))     (eval `(assert! (funcallv  #'cr::good-cs-p ,mincs ,maxcs ,.VarArray)))     (eval `(assert! (funcallv  #'cr::surface-p 0.3 0.4 ,.VarArray)))     VarArray)   (static-ordering #'divide-and-conquer-force)))#|(one-value (probleme 4 60 72 2 4))(all-values (probleme 5 60 12 4.1 4.4))(apply-n-time probleme (5 60 12 4.1 4.4) 5)|#